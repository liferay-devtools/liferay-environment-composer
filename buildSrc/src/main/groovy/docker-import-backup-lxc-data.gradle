project.plugins.apply "docker-common"

Closure<Boolean> validateDatabaseBackupFileExtensions = {
	File dumpsFolder ->

	List<File> decryptedBackupFiles = dumpsFolder.listFiles().findAll {
		it.getName().endsWith(".gz") || it.getName().endsWith(".sql")
	}

	if (decryptedBackupFiles.isEmpty()) {
		return false
	}

	decryptedBackupFiles.each {
		if (it.getName().endsWith(".gz") && !it.getName().endsWith(".sql.gz")) {
			String path = it.getAbsolutePath()
			it.renameTo("${path.substring(0, path.length() - 3)}.sql.gz")
		}
	}

	return true
}

Closure<File> getFirstMatchingSubFolder

getFirstMatchingSubFolder = {
	File folder, Closure<Boolean> predicate ->

	if (predicate(folder)) {
		return folder
	}

	List<File> subfolders = folder.listFiles().findAll {
		it.isDirectory()
	}

	if (subfolders.size() != 1) {
		return null
	}

	return getFirstMatchingSubFolder(subfolders[0], predicate)
}

Closure<Boolean> stripComponentFolders = {
	File sourceFolder, File targetFolder ->

	if (sourceFolder == null) {
		return false
	}

	if (sourceFolder.equals(targetFolder)) {
		return true
	}

	sourceFolder.listFiles().each {
		it.renameTo(new File(targetFolder, it.getName()))
	}

	File nestedFolder = sourceFolder

	while (!nestedFolder.equals(targetFolder)) {
		nestedFolder.delete()

		nestedFolder = nestedFolder.getParentFile()
	}

	return true
}

tasks.register("decryptCloudBackupDatabase") {
	doFirst {
		File dumpsFolder = new File(projectDir, "dumps")

		if (dumpsFolder.exists()) {
			if (validateDatabaseBackupFileExtensions(dumpsFolder)) {
				print("Found existing decrypted backups in ${dumpsFolder.getAbsolutePath()}")

				return
			}
		}

		File lxcFolder = new File(projectDir, "lxc")

		if (!lxcFolder.exists()) {
			throw new GradleException("Unable to identify database backup")
		}

		List<File> databaseBackupFiles = lxcFolder.listFiles().findAll {
			!it.getName().startsWith("doclib") && it.getName().endsWith(".7z")
		}

		if (databaseBackupFiles.size() != 1) {
			throw new GradleException("Unable to identify database backup")
		}

		println "Extracting LXC database backup"
		waitForCommand("7z x -aos ${databaseBackupFiles[0].getAbsolutePath()} -o${dumpsFolder.getAbsolutePath()} -p${config.lxcBackupPassword}")

		if (!stripComponentFolders(getFirstMatchingSubFolder(dumpsFolder, validateDatabaseBackupFileExtensions), dumpsFolder)) {
			throw new GradleException("Unable to identify database backup")
		}
	}
}

tasks.register("decryptCloudBackupDocumentLibrary") {
	doFirst {
		File doclibBackupsFolder = new File(projectDir, "liferay_data/document_library")

		if (!doclibBackupsFolder.exists()) {
			File lxcFolder = new File(projectDir, "lxc")

			if (!lxcFolder.exists()) {
				return
			}

			List<File> doclibBackupFiles = lxcFolder.listFiles().findAll {
				it.getName().startsWith("doclib") && it.getName().endsWith(".7z")
			}

			if (doclibBackupFiles.isEmpty()) {
				return
			}

			if (doclibBackupFiles.size() > 1) {
				throw new GradleException("Unable to identify document library backup")
			}

			println "Extracting LXC document library backup"
			waitForCommand("7z x -aos ${doclibBackupFiles[0].getAbsolutePath()} -o${doclibBackupsFolder.getAbsolutePath()} -p${config.lxcBackupPassword}")
		}

		if (!stripComponentFolders(getFirstMatchingSubFolder(doclibBackupsFolder, { it.list().contains("0") }), doclibBackupsFolder)) {
			throw new GradleException("Unable to find system folder 0 in document library backup")
		}
	}
}

Closure<Void> resetLiferayUserPasswords = {
	Map<String, String> virtualHost, String schema ->

	String companyId = virtualHost["companyId"]
	String hostname = virtualHost["hostname"]

	println ""

	executeSQLQuery("update User_ set password_ = '${config.liferayUserPassword}', passwordEncrypted = false where companyId = ${companyId}", schema)

	println "Reset all user passwords to '${config.liferayUserPassword}' for ${hostname}"

	List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)
	
	if (results.isEmpty()) {
		println("Unable to detect users explicitly granted the Administrator role")
	}
	else {
		println("Detected the following users explicitly granted the Administrator role")

		results.each {
			println " - ${it["screenName"]} (${it["emailAddress"]})"
		}
	}
}

tasks.register("updateCloudBackupDatabaseForLocalDevelopment") {
	mustRunAfter importDatabaseDumps

	onlyIf {
		config.services.contains("mysql") || config.services.contains("postgres")
	}

	doFirst {
		waitForContainer("database", "${project.ext.config.namespace}-database")
		executeSQLQuery("update VirtualHost set hostname = concat(hostname, '.localhost') where hostname <> 'localhost' and hostname not like '%.localhost'", config.databaseName)

		List<Map<String, String>> companyVirtualHosts = executeSQLQuery("select companyId, hostname, webId from VirtualHost inner join Company using (companyId) where layoutSetId = 0", config.databaseName)

		String defaultWebId = getDefaultVirtualHost(companyVirtualHosts)

		companyVirtualHosts.each {
			try {
				resetLiferayUserPasswords(it, config.databasePartitioningEnabled && it["webId"] != defaultWebId ? "lpartition_${it["companyId"]}" : config.databaseName)
			}
			catch (Exception e) {
				println "Unable to update ${it["hostname"]}: ${e.getMessage()}"
			}
		}
	}
}

tasks.register("importCloudBackupDatabase") {
	dependsOn decryptCloudBackupDatabase

	onlyIf {
		config.services.contains("mysql")
	}

	finalizedBy importDatabaseDumps
	finalizedBy updateCloudBackupDatabaseForLocalDevelopment
}

tasks.register("importCloudBackupDocumentLibrary") {
	dependsOn decryptCloudBackupDocumentLibrary
	dependsOn dockerCreate

	onlyIf {
		config.useLiferay
	}

	doFirst {
		restoreVolume("${config.namespace.toLowerCase()}_liferay-data-volume", new File(projectDir, "liferay_data"), config.documentLibraryFileListOnly)
	}
}

tasks.register("importCloudBackup") {
	dependsOn importCloudBackupDatabase
	dependsOn importCloudBackupDocumentLibrary
}