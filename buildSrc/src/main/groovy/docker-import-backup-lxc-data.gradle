project.plugins.apply "docker-common"

Closure<Boolean> validateDatabaseBackupFileExtensions = {
	File dumpsFolder ->

	List<File> decryptedBackupFiles = dumpsFolder.listFiles().findAll {
		it.getName().endsWith(".gz") || it.getName().endsWith(".sql")
	}

	if (decryptedBackupFiles.isEmpty()) {
		return false
	}

	decryptedBackupFiles.each {
		if (it.getName().endsWith(".gz") && !it.getName().endsWith(".sql.gz")) {
			String path = it.getAbsolutePath()
			it.renameTo("${path.substring(0, path.length() - 3)}.sql.gz")
		}
	}

	return true
}

Closure<File> getFirstMatchingSubFolder

getFirstMatchingSubFolder = {
	File folder, Closure<Boolean> predicate ->

	if (predicate(folder)) {
		return folder
	}

	List<File> subfolders = folder.listFiles().findAll {
		it.isDirectory()
	}

	if (subfolders.size() != 1) {
		return null
	}

	return getFirstMatchingSubFolder(subfolders[0], predicate)
}

Closure<Boolean> stripComponentFolders = {
	File sourceFolder, File targetFolder ->

	if (sourceFolder == null) {
		return false
	}

	if (sourceFolder.equals(targetFolder)) {
		return true
	}

	sourceFolder.listFiles().each {
		it.renameTo(new File(targetFolder, it.getName()))
	}

	File nestedFolder = sourceFolder

	while (!nestedFolder.equals(targetFolder)) {
		nestedFolder.delete()

		nestedFolder = nestedFolder.getParentFile()
	}

	return true
}

tasks.register("decryptCloudBackupDatabase") {
	doFirst {
		File dumpsFolder = file("dumps")

		if (dumpsFolder.exists()) {
			if (validateDatabaseBackupFileExtensions(dumpsFolder)) {
				print("Found existing decrypted backups in ${dumpsFolder.getAbsolutePath()}")

				return
			}
		}

		File lxcFolder = file("lxc")

		if (!lxcFolder.exists()) {
			throw new GradleException("Unable to identify database backup")
		}

		List<File> databaseBackupFiles = lxcFolder.listFiles().findAll {
			!it.getName().startsWith("doclib") && it.getName().endsWith(".7z")
		}

		if (databaseBackupFiles.size() != 1) {
			throw new GradleException("Unable to identify database backup")
		}

		println "Extracting LXC database backup"
		waitForCommand("7z x -aos ${databaseBackupFiles[0].getAbsolutePath()} -o${dumpsFolder.getAbsolutePath()} -p${config.lxcBackupPassword}")

		if (!stripComponentFolders(getFirstMatchingSubFolder(dumpsFolder, validateDatabaseBackupFileExtensions), dumpsFolder)) {
			throw new GradleException("Unable to identify database backup")
		}
	}
}

tasks.register("decryptCloudBackupDocumentLibrary") {
	doFirst {
		File doclibBackupsFolder = file("liferay_data/document_library")

		if (!doclibBackupsFolder.exists()) {
			File lxcFolder = file("lxc")

			if (!lxcFolder.exists()) {
				return
			}

			List<File> doclibBackupFiles = lxcFolder.listFiles().findAll {
				it.getName().startsWith("doclib") && it.getName().endsWith(".7z")
			}

			if (doclibBackupFiles.isEmpty()) {
				return
			}

			if (doclibBackupFiles.size() > 1) {
				throw new GradleException("Unable to identify document library backup")
			}

			println "Extracting LXC document library backup"
			waitForCommand("7z x -aos ${doclibBackupFiles[0].getAbsolutePath()} -o${doclibBackupsFolder.getAbsolutePath()} -p${config.lxcBackupPassword}")
		}

		if (!stripComponentFolders(getFirstMatchingSubFolder(doclibBackupsFolder, { it.list().contains("0") }), doclibBackupsFolder)) {
			throw new GradleException("Unable to find system folder 0 in document library backup")
		}
	}
}

tasks.register("listAdminUsers") {
	mustRunAfter updateDefaultVirtualHost

	onlyIf {
		config.services.contains("mysql") || config.services.contains("postgres")
	}

	doFirst {
		forEachCompanyId {
			String companyId, String hostname, String webId, String schema ->

			List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)

			println "\nhttp://${hostname}:8080/c/portal/login"

			if (results.isEmpty()) {
				println("Unable to detect users explicitly granted the Administrator role")
			}
			else {
				println("Detected the following users explicitly granted the Administrator role")

				results.each {
					println " - ${it["screenName"]} (${it["emailAddress"]})"
				}
			}
		}
	}
}

tasks.register("updateCloudBackupDatabaseForLocalDevelopment") {
	mustRunAfter importDatabaseDumps

	onlyIf {
		config.services.contains("mysql") || config.services.contains("postgres")
	}

	doFirst {
		executeSQLQuery("update VirtualHost set hostname = concat(hostname, '.localhost') where hostname <> 'localhost' and hostname not like '%.localhost'", config.databaseName)

		forEachCompanyId {
			String companyId, String hostname, String webId, String schema ->

			executeSQLQuery("update User_ set password_ = '${config.liferayUserPassword}', passwordEncrypted = false, passwordReset = false, lockout = false where companyId = ${companyId}", schema)
		}

		println "Reset all user passwords to '${config.liferayUserPassword}'"
	}

	finalizedBy updateDefaultVirtualHost
}

tasks.register("importCloudBackupDatabase") {
	dependsOn decryptCloudBackupDatabase

	onlyIf {
		config.services.contains("mysql")
	}

	finalizedBy importDatabaseDumps
	finalizedBy updateCloudBackupDatabaseForLocalDevelopment
}

tasks.register("importCloudBackupDocumentLibrary") {
	dependsOn decryptCloudBackupDocumentLibrary
	dependsOn dockerCreate

	onlyIf {
		config.useLiferay
	}

	doFirst {
		restoreVolume("${config.namespace.toLowerCase()}_liferay-data-volume", file("liferay_data"), config.documentLibraryFileListOnly)
	}
}

tasks.register("importCloudBackup") {
	dependsOn importCloudBackupDatabase
	dependsOn importCloudBackupDocumentLibrary
}