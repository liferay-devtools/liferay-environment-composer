project.plugins.apply "docker-common"

Closure<Void> validateDatabaseBackupFileExtensions = {
	File dumpsFolder ->

	List<File> decryptedBackupFiles = dumpsFolder.listFiles().findAll {
		it.getName().endsWith(".gz") || it.getName().endsWith(".sql")
	}

	if (decryptedBackupFiles.isEmpty()) {
		return false
	}

	decryptedBackupFiles.each {
		if (it.getName().endsWith(".gz") && !it.getName().endsWith(".sql.gz")) {
			String path = it.getAbsolutePath()
			it.renameTo("${path.substring(0, path.length() - 3)}.sql.gz")
		}
	}

	return true
}

tasks.register("decryptCloudBackupDatabase") {
	doFirst {
		File dumpsFolder = new File(projectDir, "dumps")

		if (dumpsFolder.exists()) {
			if (validateDatabaseBackupFileExtensions(dumpsFolder)) {
				print("Found existing decrypted backups in ${dumpsFolder.getAbsolutePath()}")

				return
			}
		}

		File lxcFolder = new File(projectDir, "lxc")

		if (!lxcFolder.exists()) {
			throw new GradleException("Unable to identify database backup")
		}

		List<File> databaseBackupFiles = lxcFolder.listFiles().findAll {
			!it.getName().startsWith("doclib") && it.getName().endsWith(".7z")
		}

		if (databaseBackupFiles.size() != 1) {
			throw new GradleException("Unable to identify database backup")
		}

		println "Extracting LXC database backup"
		waitForCommand("7z x ${databaseBackupFiles[0].getAbsolutePath()} -o${dumpsFolder.getAbsolutePath()} -p${config.lxcBackupPassword}")

		validateDatabaseBackupFileExtensions(dumpsFolder)
	}
}

tasks.register("decryptCloudBackupDocumentLibrary") {
	doFirst {
		File doclibBackupsFolder = new File(projectDir, "doclib")

		if (!doclibBackupsFolder.exists()) {
			File lxcFolder = new File(projectDir, "lxc")

			if (!lxcFolder.exists()) {
				return
			}

			List<File> doclibBackupFiles = lxcFolder.listFiles().findAll {
				it.getName().startsWith("doclib") && it.getName().endsWith(".7z")
			}

			if (doclibBackupFiles.isEmpty()) {
				return
			}

			if (doclibBackupFiles.size() > 1) {
				throw new GradleException("Unable to identify document library backup")
			}

			println "Extracting LXC document library backup"
			waitForCommand("7z x ${doclibBackupFiles[0].getAbsolutePath()} -o${doclibBackupsFolder.getAbsolutePath()} -p${config.lxcBackupPassword}")
		}

		File doclibFolder = doclibBackupsFolder;

		while (doclibFolder.list().length == 1 && !doclibFolder.list().contains("0")) {
			doclibFolder = doclibFolder.listFiles()[0]
		}

		if (!doclibFolder.list().contains("0")) {
			throw new GradleException("Unable to find system folder 0 in document library backup")
		}

		if (!doclibFolder.equals(doclibBackupsFolder)) {
			doclibFolder.listFiles().each {
				it.renameTo(new File(doclibBackupsFolder, it.getName()).getAbsolutePath())
			}

			while (!doclibFolder.equals(doclibBackupsFolder)) {
				doclibFolder.delete()

				doclibFolder = doclibFolder.getParentFile()
			}
		}
	}
}

Closure<Void> resetLiferayUserPasswords = {
	Map<String, String> virtualHost, String schema ->

	String companyId = virtualHost["companyId"]
	String hostname = virtualHost["hostname"]

	println ""

	executeSQLQuery("update User_ set password_ = '${config.liferayUserPassword}', passwordEncrypted = false where companyId = ${companyId}", schema)

	println "Reset all user passwords to '${config.liferayUserPassword}' for ${hostname}"

	List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)
	
	if (results.isEmpty()) {
		println("Unable to detect users explicitly granted the Administrator role")
	}
	else {
		println("Detected the following users explicitly granted the Administrator role")

		results.each {
			println " - ${it["screenName"]} (${it["emailAddress"]})"
		}
	}
}

tasks.register("updateCloudBackupDatabaseForLocalDevelopment") {
	doFirst {
		executeSQLQuery("update VirtualHost set hostname = concat(hostname, '.localhost') where hostname <> 'localhost' and hostname not like '%.localhost'", config.databaseName)

		List<Map<String, String>> companyVirtualHosts = executeSQLQuery("select companyId, hostname, webId from VirtualHost inner join Company using (companyId) where layoutSetId = 0", config.databaseName)

		String defaultWebId = getDefaultVirtualHost(companyVirtualHosts)

		companyVirtualHosts.each {
			try {
				resetLiferayUserPasswords(it, config.databasePartitioningEnabled && it["webId"] != defaultWebId ? "lpartition_${it["companyId"]}" : config.databaseName)
			}
			catch (Exception e) {
				println "Unable to update ${it["hostname"]}: ${e.getMessage()}"
			}
		}
	}
}

tasks.register("importCloudBackupDatabase") {
	dependsOn decryptCloudBackupDatabase

	onlyIf {
		config.services.contains("mysql")
	}

	doFirst {
		println "Loading LXC database backup into database container"
		waitForCommand("docker compose build database")

		if (config.services.contains("mysql")) {
			Map<String, String> oldVariables = [
				"max_allowed_packet": String.valueOf(1L << 26),
				"autocommit": "1",
				"unique_checks": "1",
				"foreign_key_checks": "1",
				"innodb_stats_auto_recalc": "1",
			]

			Map<String, String> newVariables = [
				"max_allowed_packet": String.valueOf(1L << 30),
				"autocommit": "0",
				"unique_checks": "0",
				"foreign_key_checks": "0",
				"innodb_stats_auto_recalc": "0",
			]

			new File(projectDir, "dumps/0.sql").withOutputStream {
				BufferedOutputStream initSQLOutputStream ->

				initSQLOutputStream << newVariables.collect { "SET GLOBAL ${it.key}=${it.value};" }.join("\n") << ";"
			}

			waitForContainer("database", "${config.namespace}-database")
			executeSQLQuery(oldVariables.collect { "SET GLOBAL ${it.key}=${it.value};\n" }.join(""))

			if (config.databasePartitioningEnabled) {
				executeSQLQuery(["lportal", "dxpcloud", "cloudsqlimport"].collect {
					"create user if not exists ${it} identified by 'lportal';\ngrant all on *.* to '${it}'@'%';\n"
				}.join(""))
			}
		}

		println "Loaded LXC database backup into database container"
	}

	finalizedBy updateCloudBackupDatabaseForLocalDevelopment
}

tasks.register("importCloudBackupDocumentLibrary") {
	dependsOn decryptCloudBackupDocumentLibrary
	dependsOn dockerCreate

	onlyIf {
		config.useLiferay
	}

	doFirst {
		restoreVolume("${config.namespace.toLowerCase()}_liferay-data-volume", new File(projectDir, "doclib"), config.documentLibraryFileListOnly)
	}
}

tasks.register("importCloudBackup") {
	dependsOn importCloudBackupDatabase
	dependsOn importCloudBackupDocumentLibrary
}