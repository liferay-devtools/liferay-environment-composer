import com.liferay.docker.workspace.environments.Config
import com.liferay.docker.workspace.environments.Util

import groovy.json.JsonSlurper

ext {
	config = new Config(project)

	fixProductVersion = {
		String productVersion ->

		return Util.fixReleaseKey(productVersion)
	}

	updateGradleLocalProperties = {
		Map<String, String> newProperties ->

		File gradleLocalPropertiesFile = file("gradle-local.properties")

		List<String> seenProperties = []
		List<String> gradleLocalPropertiesLines = []

		if (gradleLocalPropertiesFile.exists()) {
			gradleLocalPropertiesLines = gradleLocalPropertiesFile.readLines().collect {
				String line ->

				String newLine = newProperties.find {
					if (line.startsWith("${it.key}=")) {
						seenProperties.add(it.key)
						return "${it.key}=${it.value}"
					}
				}

				return newLine != null ? newLine : line
			}
		}

		gradleLocalPropertiesFile.withOutputStream {
			BufferedOutputStream outputStream ->

			gradleLocalPropertiesLines.each {
				outputStream << it << "\n"
			}

			newProperties.each {
				if (!seenProperties.contains(it.key)) {
					outputStream << it.key << "=" << it.value << "\n"
				}
			}
		}
	}

	waitForCommand = {
		String command, File workingDir = null ->

		StringBuffer err = new StringBuffer()
		StringBuffer out = new StringBuffer()

		Process process = ['bash', '-c', command].execute([], workingDir)

		process.waitForProcessOutput(out, err)

		if (process.exitValue() != 0) {
			throw new GradleException("Process exit code ${process.exitValue()}: ${err.toString()}")
		}

		if (err.length() > 0) {
			System.err.println err.toString()
		}

		return out.toString()
	}

	waitForContainer = {
		String serviceName, String containerName ->

		String serviceStatus = waitForCommand("docker compose ps ${serviceName} --format=json").trim()

		if (serviceStatus.length() > 0) {
			JsonSlurper jsonSlurper = new JsonSlurper()

			String health = jsonSlurper.parseText(serviceStatus)["Health"]

			if ((health != null) && health.equals("healthy")) {
				return
			}
		}
		else {
			println "Starting service ${serviceName}"
			waitForCommand("docker compose up -d ${serviceName}")
		}

		String status = ""

		while (!status.equals("\"healthy\"")) {
			if (status != null) {
				Thread.sleep(10000)
			}

			println "Waiting for service ${serviceName}"

			String logs = waitForCommand("docker compose logs ${serviceName} --since=10s")

			if (logs.length() > 0) {
				println logs
			}

			status = waitForCommand("docker inspect --format='{{json .State.Health.Status}}' ${containerName}").trim()
		}
	}
}

tasks.register("testFixProductVersion") {
	doLast {
		[
			["dxp-7.4.u36", "dxp-7.4.u36"],
			["dxp-7.4.u36-lts", "dxp-7.4.u36"],
			["dxp-2024.q1.1", "dxp-2024.q1.1"],
			["dxp-2024.q1.1-lts", "dxp-2024.q1.1"],
			["dxp-2025.q1.1", "dxp-2025.q1.1-lts"],
			["dxp-2025.q1.1-lts", "dxp-2025.q1.1-lts"],
			["dxp-2025.q2.1", "dxp-2025.q2.1"],
			["dxp-2025.q2.1-lts", "dxp-2025.q2.1"],
		].each {
			String input = it[0]
			String expected = it[1]

			assert expected == Util.fixReleaseKey(input)
		}
	}
}

tasks.register("runUtilTests") {
	dependsOn ":testFixProductVersion"
}