import groovy.json.JsonSlurper

ext {
	executeSQLQuery = {
		String sql, String schema = null ->

		if (config.services.contains("mysql")) {
			List<String> results = []

			if (schema == null) {
				results = waitForCommand("docker compose exec -it database mysql --batch --user=root --execute=\"${sql}\"").split("\n")
			}
			else {
				results = waitForCommand("docker compose exec -it database mysql --batch --user=root --database=${schema} --execute=\"${sql}\"").split("\n")
			}

			String[] columnHeaders = results[0].split("\t")
			
			return results.subList(1, results.size()).collect {
				[columnHeaders, it.split("\t")].transpose().collectEntries {
					[it[0], it[1]]
				}
			}
		}
		else {
			throw new GradleException("Database service not detected")
		}
	}

	getDefaultVirtualHost = {
		List<Map<String, String>> companyVirtualHosts ->

		File portalExtPropertiesFile = new File(projectDir, "configs/common/portal-ext.properties")

		String propertyDefaultWebId = null

		List<String> propertiesLines = []

		portalExtPropertiesFile.eachLine {
			String key = it.trim().split("=")[0]

			if (key.equals("company.default.web.id")) {
				defaultWebId = it.split("=")[1].trim()
			}
		}

		Map<String, String> defaultCompanyVirtualHost = null

		List<Map<String, String>> adminInstanceVirtualHosts = executeSQLQuery("select companyId from Company where webId like 'admin-%.lxc.liferay.com'", config.databaseName)

		if (!adminInstanceVirtualHosts.isEmpty()) {
			config.databasePartitioningEnabled = true
		}

		if (config.databasePartitioningEnabled) {
			String defaultCompanyId = adminInstanceVirtualHosts[0]["companyId"]

			defaultCompanyVirtualHost = companyVirtualHosts.find {
				it["companyId"] == defaultCompanyId
			}
		}
		else if (companyVirtualHosts.size() == 1) {
			defaultCompanyVirtualHost = companyVirtualHosts[0]
		}
		else if (propertyDefaultWebId != null) {
			defaultCompanyVirtualHost = companyVirtualHosts.find {
				it["webId"] == propertyDefaultWebId
			}
		}
		else {
			defaultCompanyVirtualHost = companyVirtualHosts.find {
				it["webId"] == "liferay.com"
			}
		}

		if (defaultCompanyVirtualHost == null) {
			throw new GradleException("Unable to auto-detect company.default.web.id, please set it manually in configs/common/portal-ext.properties manually")
		}

		return defaultCompanyVirtualHost["webId"]
	}

	getExistingVolumeNames = {
		String prefix ->

		JsonSlurper jsonSlurper = new JsonSlurper()

		List<String> volumeNames = []

		waitForCommand("docker volume ls --filter name=^${prefix} --format json").eachLine {
			String line ->

			volumeNames.add(jsonSlurper.parseText(line)["Name"])
		}

		return volumeNames
	}

	restoreVolume = {
		String volumeName, File backupFile, boolean importFileListOnly ->

		String importPath = backupFile.getAbsolutePath()

		if (importPath.endsWith(".tar")) {
			if (importFileListOnly) {
				println "Restoring ${volumeName} from ${importPath} (file list only)"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source.tar busybox:latest sh -c 'cd target; tar t -f /source.tar | grep \"/\$\" | sort | xargs mkdir -p; tar t -f /source.tar | grep -v \"/\$\" | xargs touch'")
			}
			else {
				println "Restoring volume ${volumeName} from ${importPath}"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source.tar busybox:latest tar x -f /source.tar -C /target/")
			}

			println waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest du -sh /target/")

			println "Restored volume ${volumeName} from ${importPath}"
		}
		else if (importPath.endsWith(".tar.gz")) {
			if (importFileListOnly) {
				println "Restoring ${volumeName} from ${importPath} (file list only)"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source.tar.gz busybox:latest sh -c 'cd target; tar t -zf /source.tar.gz | grep \"/\$\" | sort | xargs mkdir -p; tar t -zf /source.tar.gz | grep -v \"/\$\" | xargs touch'")
			}
			else {
				println "Restoring volume ${volumeName} from ${importPath}"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source.tar.gz busybox:latest tar x -zf /source.tar.gz -C /target/")
			}

			println waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest du -sh /target/")

			println "Restored volume ${volumeName} from ${importPath}"
		}
		else if (backupFile.isDirectory()) {
			if (importFileListOnly) {
				println "Copying directory ${importPath} to ${volumeName} (file list only)"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source busybox:latest sh -c 'cd /source; find . -type d | sort | sed \"s@^@/target/@g\" | xargs mkdir -p; find . -type f | sed \"s@^@/target/@g\" | xargs touch'")
			}
			else {
				println "Copying directory ${importPath} to ${volumeName}"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source busybox:latest sh -c 'cp --update --recursive /source/* /target/'")
			}

			println waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest du -sh /target/")
		}
		else if (backupFile.exists()) {
			String fileName = backupFile.getName()

			if (importFileListOnly) {
				println "Copying file ${importPath} to ${volumeName} (file list only)"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v busybox:latest touch /target/${fileName}")
			}
			else {
				println "Copying file ${importPath} to ${volumeName}"
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${importPath}:/source/${fileName} busybox:latest sh -c 'cp --update /source/* /target/'")
			}

			println waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest du -sh /target/${fileName}")

			println "Copied file ${importPath} to ${volumeName}"
		}
		else {
			throw new GradleException("Unable to find file ${importPath}")
		}
	}

	waitForCommand = {
		String command ->

		StringBuffer err = new StringBuffer()
		StringBuffer out = new StringBuffer()

		Process process = ['bash', '-c', command].execute()

		process.waitForProcessOutput(out, err)

		if (process.exitValue() != 0) {
			throw new GradleException("Process exit code ${process.exitValue()}: ${err.toString()}")
		}

		if (err.length() > 0) {
			System.err.println err.toString()
		}

		return out.toString()
	}

	waitForContainer = {
		String serviceName, String containerName ->

		println "Starting service ${serviceName}"
		waitForCommand("docker compose up -d ${serviceName}")

		String status = null

		while ((status == null) || !status.trim().equals("\"healthy\"")) {
			if (status != null) {
				Thread.sleep(10000)
			}

			println "Waiting for service ${serviceName}"

			String logs = waitForCommand("docker compose logs ${serviceName} --since=10s")

			if (logs.length() > 0) {
				println logs
			}

			status = waitForCommand("docker inspect --format='{{json .State.Health.Status}}' ${containerName}")
		}
	}
}

tasks.register("dockerCreate") {
	doFirst {
		waitForCommand("docker compose create")
	}
}