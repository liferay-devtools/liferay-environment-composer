import groovy.json.JsonSlurper

import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.util.regex.Pattern
import java.util.regex.Matcher

Closure<Boolean> copyLiferayLXCRepositoryConfiguration

copyLiferayLXCRepositoryConfiguration = {
	File configFolder, String sourceName, String targetName ->

	File sourceFile = new File(configFolder, sourceName)

	if (!sourceFile.exists()) {
		return false
	}

	File targetFile = new File(new File(projectDir, "configs"), targetName)

	if (sourceFile.isDirectory()) {
		for (String fileName : sourceFile.list()) {
			copyLiferayLXCRepositoryConfiguration(sourceFile, fileName, "${targetName}/${fileName}".toString())
		}
	}
	else {
		targetFile.getParentFile().mkdirs()

		Files.copy(sourceFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)
	}

	return true
}

Closure<Boolean> updateGradlePropertiesWithLiferayVersion = {
	String environmentName ->

	File environmentDescriptorFile = new File(new File(projectDir, config.liferayLXCRepositoryPath), "automation/environment-descriptors/${environmentName}.json")

	if (!environmentDescriptorFile.exists()) {
		return false
	}

	JsonSlurper jsonSlurper = new JsonSlurper()

	Object environmentDescriptor = jsonSlurper.parse(environmentDescriptorFile)

	String liferayImage = environmentDescriptor["liferay-image"]
	String liferayHotfix = environmentDescriptor["hotfix"]

	Pattern releasePattern = ~'[0-9]+\\.q[1-4]\\.[0-9]+'

	Matcher releaseMatcher = releasePattern.matcher(liferayImage)

	if (!releaseMatcher.find()) {
		println "did not match ${liferayImage}"
		return false
	}

	String release = releaseMatcher.group()

	if ((release.indexOf(".q1") != -1) && !release.startsWith("2024.")) {
		release = release + "-lts"
	}

	String workspaceProduct = "dxp-${release}"
	String liferayHotfixURL = "https://releases-cdn.liferay.com/dxp/hotfix/${release}/liferay-dxp-${release}-${liferayHotfix}.zip"

	File gradlePropertiesFile = new File(projectDir, "gradle.properties")

	List<String> gradlePropertiesLines = []
	
	gradlePropertiesFile.eachLine {
		if (it.startsWith("liferay.workspace.product=")) {
			gradlePropertiesLines.add("liferay.workspace.product=${workspaceProduct}")
		}
		else if (it.startsWith("liferay.workspace.docker.image.liferay=")) {
			gradlePropertiesLines.add("liferay.workspace.docker.image.liferay=${liferayImage}")
		}
		else if (it.startsWith("lr.docker.environment.hotfix.urls=")) {
			gradlePropertiesLines.add("lr.docker.environment.hotfix.urls=${liferayHotfixURL}")
		}
		else {
			gradlePropertiesLines.add(it)
		}
	}

	gradlePropertiesFile.withOutputStream {
		BufferedOutputStream outputStream ->

		gradlePropertiesLines.each {
			outputStream << it << "\n"
		}
	}

	return true
}

Closure<Void> copyLiferayLXCRepositoryConfigurations = {
	Map<String, String> defaultCompanyVirtualHost, List<String> includeAndOverride ->

	String expectedHostName = defaultCompanyVirtualHost["hostname"].substring(0, defaultCompanyVirtualHost["hostname"].length() - ".localhost".length())

	List<File> envConfigs = new File(projectDir, "${config.liferayLXCRepositoryPath}/liferay/configs").listFiles().findAll {
		File portalEnvProperties = new File(it, "portal-env.properties")

		if (!portalEnvProperties.exists()) {
			return false
		}

		String portalEnvPropertiesText = portalEnvProperties.text

		return portalEnvPropertiesText.contains("company.default.web.id=${defaultCompanyVirtualHost["webId"]}") &&
			portalEnvPropertiesText.contains("company.default.virtual.host.name=${expectedHostName}")
	}

	envConfigs.each {
		if (copyLiferayLXCRepositoryConfiguration(it, "portal-env.properties", "common/properties/lxc-portal-env-${it.getName()}.properties")) {
			includeAndOverride.add("./properties/lxc-portal-env-${it.getName()}.properties")

			println "Copied ${it.getName()}/portal-env.properties from liferay-lxc repository clone"
		}

		if (copyLiferayLXCRepositoryConfiguration(it, "scripts", "docker")) {
			println "Copied ${it.getName()}/scripts from liferay-lxc repository clone"
		}

		if (copyLiferayLXCRepositoryConfiguration(it, "osgi", "common/osgi")) {
			println "Copied ${it.getName()}/osgi from liferay-lxc repository clone"
		}

		if (updateGradlePropertiesWithLiferayVersion(it.getName())) {
			println "Updated gradle.properties with version from ${it.getName()}"
		}
	}

	new File(projectDir, "configs/common/properties/lxc.properties").text = """
database.partition.enabled=true
database.partition.thread.pool.enabled=true
company.default.web.id=${defaultCompanyVirtualHost["webId"]}
company.default.virtual.host.name=${defaultCompanyVirtualHost["hostname"]}
		"""

	includeAndOverride.add("./properties/lxc.properties")
}

tasks.register("updateDefaultVirtualHost") {
	onlyIf {
		config.services.contains("mysql") || config.services.contains("postgres")
	}

	doFirst {
		List<Map<String, String>> companyVirtualHosts = executeSQLQuery("select companyId, hostname, webId from VirtualHost inner join Company using (companyId) where layoutSetId = 0", config.databaseName)

		String defaultWebId = getDefaultVirtualHost(companyVirtualHosts)

		if (defaultWebId == null) {
			return
		}

		Map<String, String> defaultCompanyVirtualHost = companyVirtualHosts.find {
			it["webId"] == defaultWebId
		}


		File portalExtPropertiesFile = new File(projectDir, "configs/common/portal-ext.properties")

		List<String> propertiesLines = []
		List<String> includeAndOverride = []

		portalExtPropertiesFile.eachLine {
			String key = it.trim().split("=")[0]

			if (key.equals("company.default.web.id")) {
				return
			}

			if (key.equals("include-and-override")) {
				String file = it.split("=")[1].trim()

				if (!file.contains("/lxc")) {
					includeAndOverride.add(file)
				}
			}
			else {
				propertiesLines.add(it)
			}
		}

		if (config.databasePartitioningEnabled) {
			copyLiferayLXCRepositoryConfigurations(defaultCompanyVirtualHost, includeAndOverride)
		}

		portalExtPropertiesFile.withOutputStream {
			BufferedOutputStream outputStream ->

			includeAndOverride.each {
				outputStream << "include-and-override=" << it << "\n"
			}

			propertiesLines.each {
				outputStream << it << "\n"
			}
		}
	}
}