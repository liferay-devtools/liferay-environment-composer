project.plugins.apply "docker-common"

Closure<List<Map<File, String>>> getEligibleVolumeBackups = {
	String prefix, List<String> existingVolumeNames, File[] candidates ->

	return candidates.collect {
		File candidate ->

		List<File> tarFiles = candidate.listFiles().findAll {
			it.getName().endsWith(".tar") || it.getName().endsWith(".tar.gz")
		}

		Map<String, String> eligibleVolumeBackups = [:]

		tarFiles.each {
			String volumeName = prefix + it.getName().substring(0, it.getName().length() - 4)

			if (existingVolumeNames.contains(volumeName)) {
				eligibleVolumeBackups.put(it, volumeName)
			}
		}

		return eligibleVolumeBackups
	}.findAll {
		!it.isEmpty()
	}
}

tasks.register("importDatabaseDumps") {
	onlyIf {
		config.services.contains("mysql") || config.services.contains("postgres")
	}

	doFirst {
		String dataVolumeName = "${config.namespace.toLowerCase()}_database-data-volume"
		String dumpsVolumeName = "${config.namespace.toLowerCase()}_database-dumps-volume"

		waitForCommand("docker compose create")
		waitForCommand("docker compose build database")

		int currentDataVolumeSize = waitForCommand("docker run --rm -v ${dataVolumeName}:/target busybox:latest du -s /target/").split("\\s+")[0] as Integer

		if (currentDataVolumeSize > 4) {
			println "database-data-volume already contains files, assuming no further action is required"

			return
		}

		int currentDumpsVolumeSize = waitForCommand("docker run --rm -v ${dumpsVolumeName}:/target busybox:latest du -s /target/").split("\\s+")[0] as Integer

		if (currentDumpsVolumeSize > 4) {
			println "database-dumps-volume already contains files, assuming backups have been copied"
		}
		else if (config.services.contains("mysql")) {
			file("dumps").listFiles().each {
				if (it.getName().endsWith(".sql") || it.getName().endsWith(".sql.gz")) {
					restoreVolume(dumpsVolumeName, it, false)
				}
			}
		}
		else {
			restoreVolume(dumpsVolumeName, file("dumps"), false)
		}

		if (config.services.contains("mysql")) {
			println "Loading database backup into database container"

			Map<String, String> oldVariables = [
				"max_allowed_packet": String.valueOf(1L << 26),
				"autocommit": "1",
				"unique_checks": "1",
				"foreign_key_checks": "1",
				"innodb_stats_auto_recalc": "1",
			]

			Map<String, String> newVariables = [
				"max_allowed_packet": String.valueOf(1L << 30),
				"autocommit": "0",
				"unique_checks": "0",
				"foreign_key_checks": "0",
				"innodb_stats_auto_recalc": "0",
			]

			File globalVariableScript = file("0.sql")

			globalVariableScript.withOutputStream {
				BufferedOutputStream initSQLOutputStream ->

				initSQLOutputStream << newVariables.collect { "SET GLOBAL ${it.key}=${it.value};" }.join("\n") << ";"
			}

			restoreVolume(dumpsVolumeName, globalVariableScript, false)

			globalVariableScript.delete()

			executeSQLQuery(oldVariables.collect { "SET GLOBAL ${it.key}=${it.value};\n" }.join(""))

			List<Map<String, String>> adminInstanceVirtualHosts = executeSQLQuery("select companyId from Company where webId like 'admin-%.lxc.liferay.com'", config.databaseName)

			if (!adminInstanceVirtualHosts.isEmpty()) {
				config.databasePartitioningEnabled = true
			}

			if (config.databasePartitioningEnabled) {
				executeSQLQuery(["lportal", "dxpcloud", "cloudsqlimport"].collect {
					"create user if not exists ${it} identified by 'lportal';\ngrant all on *.* to '${it}'@'%';\n"
				}.join(""))
			}

			println "Loaded database backup into database container"
		}
	}
}

tasks.register("importContainerData") {
	dependsOn dockerCreate

	doFirst {
		String prefix = "${config.namespace.toLowerCase()}_"

		List<String> existingVolumeNames = getExistingVolumeNames(prefix)

		List<Map<File, String>> volumeBackups = []

		if (config.dataDirectory.length() > 0) {
			File dataFolder = file(config.dataDirectory)

			if (dataFolder.exists() && dataFolder.isDirectory()) {
				volumeBackups = getEligibleVolumeBackups(prefix, existingVolumeNames, [dataFolder] as File[])

				if (volumeBackups.isEmpty()) {
					volumeBackups = getEligibleVolumeBackups(prefix, existingVolumeNames, dataFolder.listFiles())
				}
			}
		}

		if (volumeBackups.isEmpty()) {
			File exportedDataFolder = file("exported_data")

			if (exportedDataFolder.exists() && exportedDataFolder.isDirectory()) {
				volumeBackups = getEligibleVolumeBackups(prefix, existingVolumeNames, exportedDataFolder.listFiles())
			}
		}

		if (volumeBackups.isEmpty()) {
			throw new GradleException("Please set lr.docker.environment.data.directory in gradle.properties to a folder that contains backups")
		}
		else if (volumeBackups.size() > 1) {
			throw new GradleException("Multiple exported container data folders found, please set lr.docker.environment.data.directory in gradle.properties")
		}

		volumeBackups[0].each {
			File backupFile, String volumeName ->

			restoreVolume(volumeName, backupFile, false)
		}
	}
}