project.plugins.apply "docker-common"
project.plugins.apply "docker-import-backup-localdev"
project.plugins.apply "docker-import-backup-lxc-config"
project.plugins.apply "docker-import-backup-lxc-data"

tasks.register("importDatabaseDumps") {
	dependsOn dockerCreate
	dependsOn decryptCloudBackupDatabase
	dependsOn checkCloudBackupDatabaseType

	onlyIf("using an external database") { config.useDatabase }
	onlyIf("there is a database dump file") {
		!project.fileTree("dumps") { exclude ".gitkeep" }.isEmpty()
	}

	doFirst {
		waitForCommand("docker compose build database")

		String dataVolumeName = "${config.namespace.toLowerCase()}_${config.databaseType}-data-volume"
		String dumpsVolumeName = "${config.namespace.toLowerCase()}_${config.databaseType}-dumps-volume"

		Map<String, String> diskUsageMetadata = getExistingVolumeDiskUsage()

		if (diskUsageMetadata.containsKey(dataVolumeName) && !diskUsageMetadata[dataVolumeName].toUpperCase().equals("0B")) {
			println "${dataVolumeName} already contains ${diskUsageMetadata[dataVolumeName]} of files, assuming no further action is required"

			return
		}

		if (diskUsageMetadata.containsKey(dumpsVolumeName) && !diskUsageMetadata[dumpsVolumeName].toUpperCase().equals("0B")) {
			println "${dumpsVolumeName} already contains ${currentDumpsVolumeSize} of files, assuming backups have been copied"
		}
		else {
			if (config.useDatabaseMySQL) {
				file("dumps").listFiles().each {
					if (it.name.endsWith(".sql") || it.name.endsWith(".sql.gz")) {
						restoreVolume(dumpsVolumeName, it, false)
					}
				}
			}
			else if (config.useDatabasePostgreSQL) {
				restoreVolume(dumpsVolumeName, file("dumps"), false)
			}
		}

		println "Loading database backup into database container"

		File globalVariableScript = file("0.sql")

		Map<String, String> oldVariables = [
			"max_allowed_packet": String.valueOf(1L << 26),
			"autocommit": "1",
			"unique_checks": "1",
			"foreign_key_checks": "1",
			"innodb_stats_auto_recalc": "1",
		]

		if (config.useDatabaseMySQL) {
			Map<String, String> newVariables = [
				"max_allowed_packet": String.valueOf(1L << 30),
				"autocommit": "0",
				"unique_checks": "0",
				"foreign_key_checks": "0",
				"innodb_stats_auto_recalc": "0",
			]

			globalVariableScript.withOutputStream {
				BufferedOutputStream initSQLOutputStream ->

				initSQLOutputStream << newVariables.collect { "SET GLOBAL ${it.key}=${it.value};" }.join("\n") << ";"

				if (config.databasePartitioningEnabled) {
					initSQLOutputStream << ["lportal", "dxpcloud", "cloudsqlimport"].collect {
						"create user if not exists ${it} identified by 'lportal';\ngrant all on *.* to '${it}'@'%';\n"
					}.join("\n")
				}
			}
		}
		else if (config.useDatabasePostgreSQL) {
			if (config.databasePartitioningEnabled) {
				globalVariableScript.withOutputStream {
					BufferedOutputStream initSQLOutputStream ->

					if (config.databasePartitioningEnabled) {
						initSQLOutputStream << "create role cloudsqlsuperuser with login superuser password 'lportal';"
					}
				}
			}
		}

		if (globalVariableScript.exists()) {
			restoreVolume(dumpsVolumeName, globalVariableScript, false)

			globalVariableScript.delete()
		}

		waitForContainer("database", "${config.namespace}-database")

		if (config.useDatabaseMySQL) {
			executeSQLQuery(oldVariables.collect { "SET GLOBAL ${it.key}=${it.value};\n" }.join(""))
		}

		println "Loaded database backup into database container"

		updateDatabaseForLocalDevelopment()
		updatePortalExtPropertiesWithDefaultVirtualHost()
	}
}

tasks.register("importDocumentLibrary") {
	dependsOn decryptCloudBackupDocumentLibrary
	dependsOn dockerCreate

	onlyIf {
		config.useLiferay
	}

	doFirst {
		String dataVolumeName = "${config.namespace.toLowerCase()}_liferay-data-volume"

		Map<String, String> diskUsageMetadata = getExistingVolumeDiskUsage()

		if (diskUsageMetadata.containsKey(dataVolumeName) && !diskUsageMetadata[dataVolumeName].toUpperCase().equals("0B")) {
			println "${dataVolumeName} already contains ${diskUsageMetadata[dataVolumeName]} of files, assuming no further action is required"

			return
		}

		restoreVolume(dataVolumeName, file("liferay_data"), config.documentLibraryFileListOnly)
	}
}

tasks.register("importContainerData") {
	dependsOn dockerCreate

	doFirst {
		Collection<String> existingVolumeNames = getExistingVolumeDiskUsage().keySet()

		println existingVolumeNames

		String dataDirectory = config.dataDirectory

		if (dataDirectory == null) {
			throw new GradleException("Please set lr.docker.environment.data.directory in gradle.properties to a folder that contains backups")
		}

		fileTree(config.dataDirectory) {
			include "*.tar"
			include "*.tar.gz"
		}.each {
			File backupFile ->

			String volumeName = "${config.namespace.toLowerCase()}_" + backupFile.name.substring(0, backupFile.name.lastIndexOf("."))

			if (!existingVolumeNames.contains(volumeName)) {
				throw new GradleException("Backup file ${it} could not be imported because ${volumeName} is not set in the current workspace")
			}

			restoreVolume(volumeName, backupFile, false)
		}
	}
}