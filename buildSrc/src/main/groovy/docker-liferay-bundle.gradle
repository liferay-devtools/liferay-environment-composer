import de.undercouch.gradle.tasks.download.Download

import java.nio.file.Path
import java.nio.file.Paths

project.plugins.apply "docker-common"

tasks.register("fixWorkspaceProduct") {
	doFirst {
		if (config.product == null || !config.product.contains(".q1.") || config.product.endsWith("-lts") || config.product.startsWith("2024.")) {
			return
		}

		project.updateGradleLocalProperties([
			"liferay.workspace.product": config.product + "-lts"
		])

		throw new GradleException("Changed liferay.workspace.product to ${config.product}-lts, please re-run the Gradle task")
	}
}

verifyProduct.dependsOn fixWorkspaceProduct

tasks.register("checkForLiferayLicense") {
	onlyIf("using the Liferay service") { config.useLiferay }
	onlyIf("running Liferay DXP") { config.liferayDXPImage }

	doFirst {
		FileCollection licenseXmlFileCollection = project.fileTree("configs") {
			include "**/osgi/modules/*.xml"
		}.filter {
			it.text.contains("<license>")
		}

		if (licenseXmlFileCollection.isEmpty()) {
			throw new GradleException("Please add a license to configs/common/osgi/modules/")
		}
	}
}

tasks.register("ignorePreviousHotfixes") {
	doLast {
		Set<String> includeNames = config.hotfixURLs.collect {
			Path path = Paths.get(new URI(it).path)
			return path.getName(path.nameCount - 1).toString()
		}.toSet()

		FileCollection patchFiles = project.fileTree(projectDir) {
			include "configs/**/liferay-hotfix-*.zip"
			include "configs/**/liferay-hotfix-*.zip.ignore"
			include "build/docker/configs/**/liferay-*.zip"
			include "build/docker/configs/**/liferay-*.zip.ignore"
		}

		patchFiles.each {
			String patchName = it.name.endsWith(".ignore") ? it.name.substring(0, it.name.length() - 7) : it.name

			if (includeNames.contains(patchName)) {
				if (it.name.endsWith(".ignore")) {
					it.renameTo(new File(it.absolutePath.substring(0, it.absolutePath.length() - 7)))
				}
			}
			else {
				if (!it.name.endsWith(".ignore")) {
					it.renameTo(new File(it.absolutePath + ".ignore"))
				}
			}
		}
	}
}

tasks.register("prepareHotfixes", Download) {
	dependsOn ignorePreviousHotfixes

	dest project.layout.dir(project.provider {project.file("configs/common/patching")})

	onlyIf("there are hotfix URLs defined") {
		!config.hotfixURLs.isEmpty()
	}

	src config.hotfixURLs

	overwrite false
}

tasks.register("listAdminUsers") {
	onlyIf("using an external database") { config.useDatabase }

	doFirst {
		forEachCompanyId {
			String companyId, String hostname, String webId, String schema ->

			List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)

			println "\nhttp://${hostname}:8080/c/portal/login"
			println "http://${hostname}:8080/?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=exclusive&p_p_mode=view&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Flogin&saveLastPath=false"
			println getDatabaseAccessCommand(schema)

			if (results.isEmpty()) {
				println "Unable to detect users explicitly granted the Administrator role"
			}
			else {
				println "Detected the following users explicitly granted the Administrator role"

				results.each {
					println " - ${it["screenName"]} (${it["emailAddress"]})"
				}
			}
		}
	}
}